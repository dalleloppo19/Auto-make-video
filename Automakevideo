mkdir video-generator && cd video-generator && npm init -y && npm install @google/genai @hookform/resolvers @jridgewell/trace-mapping @neondatabase/serverless @radix-ui/react-accordion @radix-ui/react-alert-dialog @radix-ui/react-aspect-ratio @radix-ui/react-avatar @radix-ui/react-checkbox @radix-ui/react-collapsible @radix-ui/react-context-menu @radix-ui/react-dialog @radix-ui/react-dropdown-menu @radix-ui/react-hover-card @radix-ui/react-label @radix-ui/react-menubar @radix-ui/react-navigation-menu @radix-ui/react-popover @radix-ui/react-progress @radix-ui/react-radio-group @radix-ui/react-scroll-area @radix-ui/react-select @radix-ui/react-separator @radix-ui/react-slider @radix-ui/react-slot @radix-ui/react-switch @radix-ui/react-tabs @radix-ui/react-toast @radix-ui/react-toggle @radix-ui/react-toggle-group @radix-ui/react-tooltip @replit/vite-plugin-cartographer @replit/vite-plugin-runtime-error-modal @tailwindcss/typography @tailwindcss/vite @tanstack/react-query @types/connect-pg-simple @types/express @types/express-session @types/node @types/passport @types/passport-local @types/react @types/react-dom @types/ws @vitejs/plugin-react autoprefixer class-variance-authority clsx cmdk connect-pg-simple date-fns drizzle-kit drizzle-orm drizzle-zod embla-carousel-react esbuild express express-session framer-motion googleapis input-otp lucide-react memorystore next-themes node-fetch passport passport-local postcss react react-day-picker react-dom react-hook-form react-icons react-resizable-panels recharts tailwind-merge tailwindcss tailwindcss-animate tsx tw-animate-css typescript vaul vite wouter ws zod zod-validation-error && mkdir -p client/src/{components/ui,hooks,lib,pages} server/services shared && echo '{"name":"video-generator","type":"module","scripts":{"dev":"NODE_ENV=development tsx server/index.ts","build":"npm run build:client && npm run build:server","build:client":"vite build","build:server":"esbuild server/index.ts --bundle --platform=node --target=node20 --outfile=dist/server.js --external:express"},"dependencies":{"@google/genai":"^1.1.0","@hookform/resolvers":"^3.9.1","@jridgewell/trace-mapping":"^0.3.25","@neondatabase/serverless":"^0.10.2","@radix-ui/react-accordion":"^1.2.1","@radix-ui/react-alert-dialog":"^1.1.2","@radix-ui/react-aspect-ratio":"^1.1.0","@radix-ui/react-avatar":"^1.1.1","@radix-ui/react-checkbox":"^1.1.2","@radix-ui/react-collapsible":"^1.1.1","@radix-ui/react-context-menu":"^2.2.2","@radix-ui/react-dialog":"^1.1.2","@radix-ui/react-dropdown-menu":"^2.1.2","@radix-ui/react-hover-card":"^1.1.2","@radix-ui/react-label":"^2.1.0","@radix-ui/react-menubar":"^1.1.2","@radix-ui/react-navigation-menu":"^1.2.1","@radix-ui/react-popover":"^1.1.2","@radix-ui/react-progress":"^1.1.0","@radix-ui/react-radio-group":"^1.2.1","@radix-ui/react-scroll-area":"^1.2.0","@radix-ui/react-select":"^2.1.2","@radix-ui/react-separator":"^1.1.0","@radix-ui/react-slider":"^1.2.1","@radix-ui/react-slot":"^1.1.0","@radix-ui/react-switch":"^1.1.1","@radix-ui/react-tabs":"^1.1.1","@radix-ui/react-toast":"^1.2.2","@radix-ui/react-toggle":"^1.1.0","@radix-ui/react-toggle-group":"^1.1.0","@radix-ui/react-tooltip":"^1.1.3","@replit/vite-plugin-cartographer":"^2.1.1","@replit/vite-plugin-runtime-error-modal":"^2.0.0","@tailwindcss/typography":"^0.5.15","@tailwindcss/vite":"^4.0.0-alpha.26","@tanstack/react-query":"^5.62.2","@types/connect-pg-simple":"^7.0.3","@types/express":"^5.0.0","@types/express-session":"^1.18.0","@types/node":"^22.10.1","@types/passport":"^1.0.16","@types/passport-local":"^1.0.38","@types/react":"^18.3.12","@types/react-dom":"^18.3.1","@types/ws":"^8.5.13","@vitejs/plugin-react":"^4.3.4","autoprefixer":"^10.4.20","class-variance-authority":"^0.7.1","clsx":"^2.1.1","cmdk":"^1.0.4","connect-pg-simple":"^10.0.0","date-fns":"^4.1.0","drizzle-kit":"^0.29.0","drizzle-orm":"^0.36.4","drizzle-zod":"^0.7.0","embla-carousel-react":"^8.3.1","esbuild":"^0.24.0","express":"^4.21.1","express-session":"^1.18.1","framer-motion":"^11.13.1","googleapis":"^144.0.0","input-otp":"^1.4.1","lucide-react":"^0.460.0","memorystore":"^1.6.7","next-themes":"^0.4.4","node-fetch":"^3.3.2","passport":"^0.7.0","passport-local":"^1.0.0","postcss":"^8.5.0","react":"^18.3.1","react-day-picker":"^9.4.2","react-dom":"^18.3.1","react-hook-form":"^7.54.0","react-icons":"^5.4.0","react-resizable-panels":"^2.1.7","recharts":"^2.13.3","tailwind-merge":"^2.5.4","tailwindcss":"^3.4.14","tailwindcss-animate":"^1.0.7","tsx":"^4.19.2","tw-animate-css":"^1.0.1","typescript":"^5.6.3","vaul":"^1.1.1","vite":"^6.0.1","wouter":"^3.3.5","ws":"^8.18.0","zod":"^3.23.8","zod-validation-error":"^3.4.0"}}' > package.json && echo 'import { defineConfig } from "vite"; import react from "@vitejs/plugin-react"; import { resolve } from "path"; export default defineConfig({ plugins: [react()], resolve: { alias: { "@": resolve(__dirname, "./client/src"), "@assets": resolve(__dirname, "./attached_assets") } }, root: "./client", build: { outDir: "../dist/client" } });' > vite.config.ts && echo 'export default { content: ["./client/**/*.{js,ts,jsx,tsx}"], darkMode: ["class"], theme: { extend: { borderRadius: { lg: "var(--radius)", md: "calc(var(--radius) - 2px)", sm: "calc(var(--radius) - 4px)" }, colors: { background: "hsl(var(--background))", foreground: "hsl(var(--foreground))", card: { DEFAULT: "hsl(var(--card))", foreground: "hsl(var(--card-foreground))" }, popover: { DEFAULT: "hsl(var(--popover))", foreground: "hsl(var(--popover-foreground))" }, primary: { DEFAULT: "hsl(var(--primary))", foreground: "hsl(var(--primary-foreground))" }, secondary: { DEFAULT: "hsl(var(--secondary))", foreground: "hsl(var(--secondary-foreground))" }, muted: { DEFAULT: "hsl(var(--muted))", foreground: "hsl(var(--muted-foreground))" }, accent: { DEFAULT: "hsl(var(--accent))", foreground: "hsl(var(--accent-foreground))" }, destructive: { DEFAULT: "hsl(var(--destructive))", foreground: "hsl(var(--destructive-foreground))" }, border: "hsl(var(--border))", input: "hsl(var(--input))", ring: "hsl(var(--ring))", chart: { "1": "hsl(var(--chart-1))", "2": "hsl(var(--chart-2))", "3": "hsl(var(--chart-3))", "4": "hsl(var(--chart-4))", "5": "hsl(var(--chart-5))" } } } }, plugins: [] };' > tailwind.config.ts && echo 'export default { plugins: { tailwindcss: {}, autoprefixer: {} } };' > postcss.config.js && echo '{ "compilerOptions": { "target": "ES2020", "useDefineForClassFields": true, "lib": ["ES2020", "DOM", "DOM.Iterable"], "module": "ESNext", "skipLibCheck": true, "moduleResolution": "bundler", "allowImportingTsExtensions": true, "resolveJsonModule": true, "isolatedModules": true, "noEmit": true, "jsx": "react-jsx", "strict": true, "noUnusedLocals": true, "noUnusedParameters": true, "noFallthroughCasesInSwitch": true, "paths": { "@/*": ["./client/src/*"], "@assets/*": ["./attached_assets/*"] } }, "include": ["client/**/*", "server/**/*", "shared/**/*"], "exclude": ["node_modules"] }' > tsconfig.json && echo '{ "$schema": "https://ui.shadcn.com/schema.json", "style": "new-york", "rsc": false, "tsx": true, "tailwind": { "config": "tailwind.config.ts", "css": "client/src/index.css", "baseColor": "slate", "cssVariables": true, "prefix": "" }, "aliases": { "components": "@/components", "utils": "@/lib/utils", "ui": "@/components/ui", "lib": "@/lib", "hooks": "@/hooks" } }' > components.json && echo 'import { pgTable, text, integer, timestamp, boolean } from "drizzle-orm/pg-core"; import { createInsertSchema } from "drizzle-zod"; import { z } from "zod"; export const users = pgTable("users", { id: integer("id").primaryKey().generatedByDefaultAsIdentity(), username: text("username").unique().notNull(), createdAt: timestamp("created_at").defaultNow().notNull() }); export const videoScripts = pgTable("video_scripts", { id: integer("id").primaryKey().generatedByDefaultAsIdentity(), topic: text("topic").notNull(), duration: integer("duration").notNull(), hook: text("hook").notNull(), opening: text("opening").notNull(), content: text("content").notNull(), cta: text("cta").notNull(), createdAt: timestamp("created_at").defaultNow().notNull() }); export const mediaFiles = pgTable("media_files", { id: integer("id").primaryKey().generatedByDefaultAsIdentity(), originalId: integer("original_id").notNull(), type: text("type", { enum: ["image", "video"] }).notNull(), filename: text("filename").notNull(), downloadUrl: text("download_url").notNull(), pexelsUrl: text("pexels_url").notNull(), photographer: text("photographer").notNull(), alt: text("alt"), duration: integer("duration"), thumbnail: text("thumbnail").notNull(), createdAt: timestamp("created_at").defaultNow().notNull() }); export const insertUserSchema = createInsertSchema(users).pick({ username: true }); export const insertVideoScriptSchema = createInsertSchema(videoScripts).omit({ id: true, createdAt: true }); export const insertMediaFileSchema = createInsertSchema(mediaFiles).omit({ id: true, createdAt: true }); export const generateScriptRequestSchema = z.object({ topic: z.string().min(1, "Topic is required"), duration: z.number().min(30).max(300), imageCount: z.number().min(1).max(10).default(3), videoCount: z.number().min(1).max(5).default(2) }); export type InsertUser = z.infer<typeof insertUserSchema>; export type User = typeof users.$inferSelect; export type VideoScript = typeof videoScripts.$inferSelect; export type InsertVideoScript = z.infer<typeof insertVideoScriptSchema>; export type MediaFile = typeof mediaFiles.$inferSelect; export type InsertMediaFile = z.infer<typeof insertMediaFileSchema>; export type GenerateScriptRequest = z.infer<typeof generateScriptRequestSchema>;' > shared/schema.ts && echo 'import { InsertUser, User } from "../shared/schema"; export interface IStorage { getUser(id: number): Promise<User | undefined>; getUserByUsername(username: string): Promise<User | undefined>; createUser(user: InsertUser): Promise<User>; } export class MemStorage implements IStorage { private users: Map<number, User>; currentId: number; constructor() { this.users = new Map(); this.currentId = 1; } async getUser(id: number): Promise<User | undefined> { return this.users.get(id); } async getUserByUsername(username: string): Promise<User | undefined> { for (const user of this.users.values()) { if (user.username === username) { return user; } } return undefined; } async createUser(insertUser: InsertUser): Promise<User> { const id = this.currentId++; const user: User = { ...insertUser, id, createdAt: new Date() }; this.users.set(id, user); return user; } } export const storage = new MemStorage();' > server/storage.ts && echo 'import { GoogleGenAI } from "@google/genai"; export interface ScriptStructure { hook: string; opening: string; content: string; cta: string; duration: number; } const ai = new GoogleGenAI({ apiKey: process.env.GEMINI_API_KEY || process.env.GOOGLE_API_KEY || "" }); export async function generateVideoScript(topic: string, duration: number): Promise<ScriptStructure> { try { const systemPrompt = `Kamu adalah copywriter ahli yang membuat script video viral untuk social media vertikal. Buatlah script video dalam bahasa Indonesia yang engaging dan natural. Format output harus JSON dengan struktur: {"hook": "kalimat pembuka menarik", "opening": "perkenalan singkat topik", "content": "isi utama dengan tips/informasi", "cta": "call to action menarik", "duration": durasi_detik} Pastikan: - Hook maksimal 10 kata yang bikin penonton penasaran - Opening singkat dan relatable - Content berisi poin-poin berguna, mudah dipahami - CTA ajak subscribe/share/save - Total durasi sesuai permintaan - Gunakan bahasa santai tapi informatif - Hindari kata "guys", gunakan "kamu" atau "kalian"`; const prompt = `Buatlah script video tentang "${topic}" dengan durasi ${duration} detik. Script harus engaging untuk format video vertikal 9:16.`; const response = await ai.models.generateContent({ model: "gemini-2.0-flash-exp", config: { systemInstruction: systemPrompt, responseMimeType: "application/json", responseSchema: { type: "object", properties: { hook: { type: "string" }, opening: { type: "string" }, content: { type: "string" }, cta: { type: "string" }, duration: { type: "number" } }, required: ["hook", "opening", "content", "cta", "duration"] } }, contents: prompt }); const rawJson = response.text; if (rawJson) { const scriptData: ScriptStructure = JSON.parse(rawJson); return scriptData; } else { throw new Error("Empty response from model"); } } catch (error) { throw new Error(`Failed to generate script: ${error}`); } } export async function generateMediaSearchQueries(topic: string, count: number): Promise<string[]> { try { const prompt = `Generate ${count} different search queries in English for finding stock photos and videos related to "${topic}". Return as JSON array of strings. Focus on visual elements, actions, and scenes that would be good for vertical video content.`; const response = await ai.models.generateContent({ model: "gemini-2.0-flash-exp", config: { responseMimeType: "application/json", responseSchema: { type: "array", items: { type: "string" } } }, contents: prompt }); const rawJson = response.text; if (rawJson) { return JSON.parse(rawJson); } else { throw new Error("Empty response from model"); } } catch (error) { console.error("Error generating search queries:", error); return [topic]; } }' > server/services/gemini.ts && echo 'export interface PexelsImage { id: number; width: number; height: number; url: string; photographer: string; photographer_url: string; photographer_id: number; avg_color: string; src: { original: string; large2x: string; large: string; medium: string; small: string; portrait: string; landscape: string; tiny: string; }; liked: boolean; alt: string; } export interface PexelsVideo { id: number; width: number; height: number; duration: number; full_res: string | null; tags: string[]; url: string; image: string; avg_color: string; user: { id: number; name: string; url: string; }; video_files: Array<{ id: number; quality: string; file_type: string; width: number; height: number; fps: number; link: string; }>; video_pictures: Array<{ id: number; nr: number; picture: string; }>; } export interface MediaSearchResult { images: PexelsImage[]; videos: PexelsVideo[]; } const PEXELS_API_KEY = process.env.PEXELS_API_KEY; const BASE_URL = "https://api.pexels.com/v1"; const VIDEO_BASE_URL = "https://api.pexels.com/videos"; async function makeRequest(url: string): Promise<any> { const response = await fetch(url, { headers: { Authorization: PEXELS_API_KEY || "" } }); if (!response.ok) { throw new Error(`Pexels API error: ${response.status} ${response.statusText}`); } return response.json(); } export async function searchImages(query: string, count: number = 5): Promise<PexelsImage[]> { try { const url = `${BASE_URL}/search?query=${encodeURIComponent(query)}&per_page=${count}&orientation=portrait`; const data = await makeRequest(url); const filteredImages = data.photos.filter((photo: PexelsImage) => { const aspectRatio = photo.height / photo.width; return aspectRatio >= 1.5; }); return filteredImages.slice(0, count); } catch (error) { console.error("Error searching images:", error); return []; } } export async function searchVideos(query: string, count: number = 2): Promise<PexelsVideo[]> { try { const url = `${VIDEO_BASE_URL}/search?query=${encodeURIComponent(query)}&per_page=${count}&orientation=portrait`; const data = await makeRequest(url); const filteredVideos = data.videos.filter((video: PexelsVideo) => { const aspectRatio = video.height / video.width; return aspectRatio >= 1.5 && video.duration >= 5; }); return filteredVideos.slice(0, count); } catch (error) { console.error("Error searching videos:", error); return []; } } export async function searchMediaForTopic(topic: string, imageCount: number, videoCount: number): Promise<MediaSearchResult> { try { const [images, videos] = await Promise.all([ searchImages(topic, imageCount), searchVideos(topic, videoCount) ]); return { images, videos }; } catch (error) { console.error("Error in searchMediaForTopic:", error); return { images: [], videos: [] }; } } export function getOptimalImageUrl(image: PexelsImage): string { return image.src.large || image.src.original; } export function getOptimalVideoUrl(video: PexelsVideo): string { const hdFile = video.video_files.find(file => file.quality === "hd" && file.width <= 1080) || video.video_files.find(file => file.quality === "sd") || video.video_files[0]; return hdFile?.link || ""; }' > server/services/pexels.ts && echo 'import { google } from "googleapis"; import fetch from "node-fetch"; import { Readable } from "stream"; function initializeDrive() { const auth = new google.auth.OAuth2( process.env.GOOGLE_CLIENT_ID, process.env.GOOGLE_CLIENT_SECRET ); auth.setCredentials({ refresh_token: process.env.GOOGLE_REFRESH_TOKEN }); return google.drive({ version: "v3", auth }); } export interface DriveUploadResult { id: string; name: string; webViewLink: string; webContentLink: string; } export async function uploadToDrive( fileName: string, buffer: Buffer, mimeType: string, folderId?: string ): Promise<DriveUploadResult> { try { const drive = initializeDrive(); const fileMetadata: any = { name: fileName }; if (folderId) { fileMetadata.parents = [folderId]; } const media = { mimeType: mimeType, body: Readable.from(buffer) }; const response = await drive.files.create({ requestBody: fileMetadata, media: media, fields: "id,name,webViewLink,webContentLink" }); if (!response.data.id) { throw new Error("Failed to get file ID from Drive response"); } await drive.permissions.create({ fileId: response.data.id, requestBody: { role: "reader", type: "anyone" } }); return { id: response.data.id, name: response.data.name || fileName, webViewLink: response.data.webViewLink || "", webContentLink: response.data.webContentLink || "" }; } catch (error) { console.error("Google Drive upload error:", error); throw new Error(`Failed to upload to Google Drive: ${error}`); } } export async function createDriveFolder(folderName: string): Promise<string> { try { const drive = initializeDrive(); const folderMetadata = { name: folderName, mimeType: "application/vnd.google-apps.folder", parents: ["root"] }; const response = await drive.files.create({ requestBody: folderMetadata, fields: "id" }); await drive.permissions.create({ fileId: response.data.id!, requestBody: { role: "reader", type: "anyone" } }); return response.data.id!; } catch (error) { console.error("Error creating Drive folder:", error); throw new Error(`Failed to create Drive folder: ${error}`); } } export async function uploadMediaToDrive( mediaFiles: Array<{ id: number; type: "image" | "video"; downloadUrl: string; photographer: string; }>, folderName: string ): Promise<Array<{ id: string; name: string; webViewLink: string; webContentLink: string; originalId: number; type: "image" | "video"; }>> { try { const folderId = await createDriveFolder(folderName); const uploadPromises = mediaFiles.map(async (media) => { const response = await fetch(media.downloadUrl); if (!response.ok) { throw new Error(`Failed to download media: ${response.statusText}`); } const buffer = Buffer.from(await response.arrayBuffer()); const extension = media.type === "video" ? "mp4" : "jpg"; const fileName = `${media.type}_${media.id}_by_${media.photographer.replace(/\s+/g, "_")}.${extension}`; const mimeType = media.type === "video" ? "video/mp4" : "image/jpeg"; const result = await uploadToDrive(fileName, buffer, mimeType, folderId); return { ...result, originalId: media.id, type: media.type }; }); const results = await Promise.all(uploadPromises); console.log(`Successfully uploaded ${results.length} files to Google Drive folder: ${folderName}`); return results; } catch (error) { console.error("Batch upload error:", error); throw new Error(`Failed to upload media to Drive: ${error}`); } } export function checkDriveCredentials(): boolean { return !!(process.env.GOOGLE_CLIENT_ID && process.env.GOOGLE_CLIENT_SECRET && process.env.GOOGLE_REFRESH_TOKEN); }' > server/services/googleDrive.ts && echo 'import express, { type Express, type Request, type Response, type NextFunction } from "express"; import { Server } from "http"; import { generateVideoScript, generateMediaSearchQueries } from "./services/gemini"; import { searchMediaForTopic, getOptimalImageUrl, getOptimalVideoUrl, type PexelsImage, type PexelsVideo } from "./services/pexels"; import { uploadMediaToDrive, checkDriveCredentials } from "./services/googleDrive"; import { generateScriptRequestSchema } from "../shared/schema"; export async function registerRoutes(app: Express): Promise<Server> { app.get("/api/status", (req: Request, res: Response) => { res.json({ status: "online", apis: { gemini: !!(process.env.GEMINI_API_KEY || process.env.GOOGLE_API_KEY), pexels: !!process.env.PEXELS_API_KEY, googleDrive: checkDriveCredentials() } }); }); app.post("/api/generate-script", async (req: Request, res: Response) => { try { const validatedData = generateScriptRequestSchema.parse(req.body); const { topic, duration, imageCount, videoCount } = validatedData; const [script, mediaResult] = await Promise.all([ generateVideoScript(topic, duration), searchMediaForTopic(topic, imageCount, videoCount) ]); const mediaFiles = [ ...mediaResult.images.map((img: PexelsImage) => ({ id: img.id, type: "image" as const, filename: `image_${img.id}.jpg`, downloadUrl: getOptimalImageUrl(img), pexelsUrl: img.url, photographer: img.photographer, alt: img.alt, thumbnail: img.src.medium })), ...mediaResult.videos.map((vid: PexelsVideo) => ({ id: vid.id, type: "video" as const, filename: `video_${vid.id}.mp4`, downloadUrl: getOptimalVideoUrl(vid), pexelsUrl: vid.url, photographer: vid.user.name, duration: vid.duration, thumbnail: vid.image })) ]; let driveLinks = []; if (checkDriveCredentials() && mediaFiles.length > 0) { try { const folderName = `${topic.substring(0, 30)}_${Date.now()}`; const mediaForUpload = mediaFiles.map(media => ({ id: media.id, type: media.type, downloadUrl: media.downloadUrl, photographer: media.photographer })); driveLinks = await uploadMediaToDrive(mediaForUpload, folderName); console.log(`Successfully uploaded ${driveLinks.length} files to Google Drive`); } catch (error) { console.error("Drive upload failed, continuing without it:", error); } } res.json({ script: { ...script, topic }, media: { images: mediaResult.images.map((img: PexelsImage) => ({ id: img.id, type: "image" as const, filename: `image_${img.id}.jpg`, downloadUrl: getOptimalImageUrl(img), pexelsUrl: img.url, photographer: img.photographer, alt: img.alt, thumbnail: img.src.medium })), videos: mediaResult.videos.map((vid: PexelsVideo) => ({ id: vid.id, type: "video" as const, filename: `video_${vid.id}.mp4`, downloadUrl: getOptimalVideoUrl(vid), pexelsUrl: vid.url, photographer: vid.user.name, duration: vid.duration, thumbnail: vid.image })), total: mediaFiles.length }, ...(driveLinks.length > 0 && { driveLinks }) }); } catch (error) { console.error("Script generation error:", error); res.status(500).json({ error: "Failed to generate script and media" }); } }); const httpServer = app.listen(5000, "0.0.0.0", () => { console.log("Server running on port 5000"); }); return httpServer; }' > server/routes.ts && echo 'import express, { type Request, type Response, type NextFunction } from "express"; import { registerRoutes } from "./routes"; import { setupVite, serveStatic, log } from "./vite"; const app = express(); app.use(express.json()); app.use(express.urlencoded({ extended: true })); app.use((req, res, next) => { res.header("Access-Control-Allow-Origin", "*"); res.header("Access-Control-Allow-Methods", "GET,PUT,POST,DELETE,OPTIONS"); res.header("Access-Control-Allow-Headers", "Content-Type, Authorization"); if (req.method === "OPTIONS") { res.sendStatus(200); } else { next(); } }); (async () => { const server = await registerRoutes(app); if (process.env.NODE_ENV === "development") { await setupVite(app, server); } else { serveStatic(app); } })(); app.use((err: any, _req: Request, res: Response, _next: NextFunction) => { const status = err.status || err.statusCode || 500; const message = err.message || "Internal Server Error"; res.status(status).json({ message }); });' > server/index.ts && echo 'import type { Express } from "express"; import type { Server } from "http"; import { createServer as createViteServer, type ViteDevServer } from "vite"; export function log(message: string, source = "express") { const formattedTime = new Date().toLocaleTimeString("en-US", { hour12: false, hour: "2-digit", minute: "2-digit", second: "2-digit" }); console.log(`${formattedTime} [${source}] ${message}`); } export async function setupVite(app: Express, server: Server) { const vite = await createViteServer({ server: { middlewareMode: true }, appType: "spa", }); app.use(vite.ssrFixStacktrace); app.use(vite.middlewares); } export function serveStatic(app: Express) { app.use(express.static("dist/client")); }' > server/vite.ts && echo '<!DOCTYPE html> <html lang="id"> <head> <meta charset="UTF-8" /> <link rel="icon" type="image/svg+xml" href="/vite.svg" /> <meta name="viewport" content="width=device-width, initial-scale=1.0" /> <title>Video Script Generator</title> <meta name="description" content="Generate AI-powered video scripts with automatic media downloads for vertical social media content" /> </head> <body> <div id="root"></div> <script type="module" src="/src/main.tsx"></script> </body> </html>' > client/index.html && echo '@tailwind base; @tailwind components; @tailwind utilities; @layer base { :root { --background: 0 0% 100%; --foreground: 222.2 84% 4.9%; --card: 0 0% 100%; --card-foreground: 222.2 84% 4.9%; --popover: 0 0% 100%; --popover-foreground: 222.2 84% 4.9%; --primary: 222.2 47.4% 11.2%; --primary-foreground: 210 40% 98%; --secondary: 210 40% 96%; --secondary-foreground: 222.2 84% 4.9%; --muted: 210 40% 96%; --muted-foreground: 215.4 16.3% 46.9%; --accent: 210 40% 96%; --accent-foreground: 222.2 84% 4.9%; --destructive: 0 84.2% 60.2%; --destructive-foreground: 210 40% 98%; --border: 214.3 31.8% 91.4%; --input: 214.3 31.8% 91.4%; --ring: 222.2 84% 4.9%; --chart-1: 12 76% 61%; --chart-2: 173 58% 39%; --chart-3: 197 37% 24%; --chart-4: 43 74% 66%; --chart-5: 27 87% 67%; --radius: 0.5rem; } .dark { --background: 222.2 84% 4.9%; --foreground: 210 40% 98%; --card: 222.2 84% 4.9%; --card-foreground: 210 40% 98%; --popover: 222.2 84% 4.9%; --popover-foreground: 210 40% 98%; --primary: 210 40% 98%; --primary-foreground: 222.2 47.4% 11.2%; --secondary: 217.2 32.6% 17.5%; --secondary-foreground: 210 40% 98%; --muted: 217.2 32.6% 17.5%; --muted-foreground: 215 20.2% 65.1%; --accent: 217.2 32.6% 17.5%; --accent-foreground: 210 40% 98%; --destructive: 0 62.8% 30.6%; --destructive-foreground: 210 40% 98%; --border: 217.2 32.6% 17.5%; --input: 217.2 32.6% 17.5%; --ring: 212.7 26.8% 83.9%; --chart-1: 220 70% 50%; --chart-2: 160 60% 45%; --chart-3: 30 80% 55%; --chart-4: 280 65% 60%; --chart-5: 340 75% 55%; } } @layer base { * { @apply border-border; } body { @apply bg-background text-foreground; } }' > client/src/index.css && echo 'import { StrictMode } from "react"; import { createRoot } from "react-dom/client"; import "./index.css"; import App from "./App.tsx"; createRoot(document.getElementById("root")!).render( <StrictMode> <App /> </StrictMode> );' > client/src/main.tsx && echo 'import { QueryClient, QueryClientProvider } from "@tanstack/react-query"; import { Router, Route } from "wouter"; import VideoGenerator from "./pages/video-generator"; import NotFound from "./pages/not-found"; import { queryClient } from "./lib/queryClient"; function AppRouter() { return ( <Router> <Route path="/" component={VideoGenerator} /> <Route component={NotFound} /> </Router> ); } function App() { return ( <QueryClientProvider client={queryClient}> <AppRouter /> </QueryClientProvider> ); } export default App;' > client/src/App.tsx && echo 'import { QueryClient } from "@tanstack/react-query"; export const queryClient = new QueryClient({ defaultOptions: { queries: { queryFn: async ({ queryKey }) => { const response = await fetch(queryKey[0] as string); if (!response.ok) { throw new Error(`HTTP error! status: ${response.status}`); } return response.json(); }, staleTime: 5 * 60 * 1000, retry: 1 } } }); export async function apiRequest( endpoint: string, options: RequestInit = {} ): Promise<Response> { const response = await fetch(endpoint, { headers: { "Content-Type": "application/json", ...options.headers }, ...options }); return response; }' > client/src/lib/queryClient.ts && echo 'import { type ClassValue, clsx } from "clsx"; import { twMerge } from "tailwind-merge"; export function cn(...inputs: ClassValue[]) { return twMerge(clsx(inputs)); }' > client/src/lib/utils.ts && echo 'import { Button } from "@/components/ui/button"; import { Link } from "wouter"; export default function NotFound() { return ( <div className="min-h-screen flex items-center justify-center bg-gradient-to-br from-slate-50 via-white to-slate-100"> <div className="text-center space-y-6 px-4"> <div className="space-y-2"> <h1 className="text-6xl font-bold text-slate-900">404</h1> <h2 className="text-2xl font-semibold text-slate-700">Halaman Tidak Ditemukan</h2> <p className="text-slate-600 max-w-md mx-auto"> Maaf, halaman yang Anda cari tidak ditemukan. Silakan kembali ke halaman utama untuk membuat script video. </p> </div> <Link href="/"> <Button className="bg-gradient-to-r from-blue-500 to-purple-600 hover:from-blue-600 hover:to-purple-700"> Kembali ke Beranda </Button> </Link> </div> </div> ); }' > client/src/pages/not-found.tsx && echo 'import { useState } from "react"; import { useQuery, useMutation } from "@tanstack/react-query"; import { Button } from "@/components/ui/button"; import { Input } from "@/components/ui/input"; import { Card } from "@/components/ui/card"; import { Textarea } from "@/components/ui/textarea"; import { Label } from "@/components/ui/label"; import { Slider } from "@/components/ui/slider"; import { Badge } from "@/components/ui/badge"; import { Separator } from "@/components/ui/separator"; import { Loader2, Wand2, Download, Share, Copy, Plus, Video, Image, CheckCircle, Clock, Zap, TrendingUp } from "lucide-react"; import { apiRequest, queryClient } from "@/lib/queryClient"; import { cn } from "@/lib/utils"; interface GeneratedScript { topic: string; duration: number; hook: string; opening: string; content: string; cta: string; } interface MediaFile { id: number; type: "image" | "video"; filename: string; downloadUrl: string; pexelsUrl: string; photographer: string; alt?: string; duration?: number; thumbnail: string; } interface DriveFile { id: string; name: string; webViewLink: string; webContentLink: string; originalId: number; type: "image" | "video"; } interface GenerationResponse { script: GeneratedScript; media: { images: MediaFile[]; videos: MediaFile[]; total: number; }; driveLinks?: DriveFile[]; } interface ApiStatus { status: string; apis: { gemini: boolean; pexels: boolean; googleDrive: boolean; }; } export default function VideoGenerator() { const [topic, setTopic] = useState(""); const [duration, setDuration] = useState([90]); const [imageCount, setImageCount] = useState([3]); const [videoCount, setVideoCount] = useState([2]); const [currentStep, setCurrentStep] = useState<"idle" | "generating" | "completed">("idle"); const [generatedContent, setGeneratedContent] = useState<GenerationResponse | null>(null); const { data: apiStatus } = useQuery<ApiStatus>({ queryKey: ["/api/status"], refetchInterval: 30000 }); const generateMutation = useMutation({ mutationFn: async () => { const response = await apiRequest("/api/generate-script", { method: "POST", body: JSON.stringify({ topic, duration: duration[0], imageCount: imageCount[0], videoCount: videoCount[0] }) }); if (!response.ok) { throw new Error("Failed to generate content"); } return response.json(); }, onSuccess: (data: GenerationResponse) => { setGeneratedContent(data); setCurrentStep("completed"); }, onError: (error) => { console.error("Generation failed:", error); setCurrentStep("idle"); } }); const handleGenerate = () => { if (!topic.trim()) return; setCurrentStep("generating"); generateMutation.mutate(); }; const handleDownload = async (media: MediaFile) => { try { const response = await fetch(media.downloadUrl); const blob = await response.blob(); const url = window.URL.createObjectURL(blob); const a = document.createElement("a"); a.style.display = "none"; a.href = url; a.download = media.filename; document.body.appendChild(a); a.click(); window.URL.revokeObjectURL(url); document.body.removeChild(a); } catch (error) { console.error("Download failed:", error); } }; const copyToClipboard = (text: string) => { navigator.clipboard.writeText(text); }; const formatScript = (script: GeneratedScript) => { return `HOOK:\n${script.hook}\n\nOPENING:\n${script.opening}\n\nCONTENT:\n${script.content}\n\nCTA:\n${script.cta}`; }; return ( <div className="min-h-screen bg-gradient-to-br from-slate-50 via-white to-slate-100"> <div className="container mx-auto px-4 py-8 max-w-4xl"> {/* Header */} <div className="text-center mb-8"> <div className="flex items-center justify-center mb-4"> <div className="w-12 h-12 bg-gradient-to-r from-purple-500 to-blue-600 rounded-xl flex items-center justify-center"> <Wand2 className="text-white w-6 h-6" /> </div> </div> <h1 className="text-4xl font-bold text-slate-900 mb-2">AI Video Script Generator</h1> <p className="text-slate-600 max-w-2xl mx-auto">Buat script video viral untuk konten vertikal dengan AI. Dapatkan script terstruktur plus media HD siap pakai dalam hitungan detik!</p> {apiStatus && ( <div className="flex items-center justify-center mt-4 space-x-4"> <Badge variant={apiStatus.apis.gemini ? "default" : "destructive"}> Gemini AI: {apiStatus.apis.gemini ? "Ready" : "Error"} </Badge> <Badge variant={apiStatus.apis.pexels ? "default" : "destructive"}> Pexels: {apiStatus.apis.pexels ? "Ready" : "Error"} </Badge> <Badge variant={apiStatus.apis.googleDrive ? "default" : "secondary"}> Drive: {apiStatus.apis.googleDrive ? "Ready" : "Optional"} </Badge> </div> )} </div> {/* Main Content */} <div className="space-y-6"> {/* Input Form */} {currentStep !== "completed" && ( <Card className="p-6 border-2 border-slate-200 shadow-lg"> <div className="space-y-6"> <div className="space-y-2"> <Label htmlFor="topic" className="text-base font-semibold">Topik Video</Label> <Input id="topic" placeholder="Contoh: cara memasak nasi goreng enak, tips olahraga pagi, review gadget terbaru..." value={topic} onChange={(e) => setTopic(e.target.value)} className="text-base" disabled={currentStep === "generating"} /> </div> <div className="grid grid-cols-1 md:grid-cols-3 gap-6"> <div className="space-y-3"> <Label className="text-sm font-medium">Durasi Video: {duration[0]} detik</Label> <Slider value={duration} onValueChange={setDuration} max={200} min={30} step={10} className="w-full" disabled={currentStep === "generating"} /> <div className="flex justify-between text-xs text-slate-500"> <span>30s</span> <span>200s</span> </div> </div> <div className="space-y-3"> <Label className="text-sm font-medium">Jumlah Gambar: {imageCount[0]}</Label> <Slider value={imageCount} onValueChange={setImageCount} max={8} min={1} step={1} className="w-full" disabled={currentStep === "generating"} /> <div className="flex justify-between text-xs text-slate-500"> <span>1</span> <span>8</span> </div> </div> <div className="space-y-3"> <Label className="text-sm font-medium">Jumlah Video: {videoCount[0]}</Label> <Slider value={videoCount} onValueChange={setVideoCount} max={5} min={1} step={1} className="w-full" disabled={currentStep === "generating"} /> <div className="flex justify-between text-xs text-slate-500"> <span>1</span> <span>5</span> </div> </div> </div> <Button onClick={handleGenerate} disabled={!topic.trim() || currentStep === "generating"} className="w-full bg-gradient-to-r from-purple-500 to-blue-600 hover:from-purple-600 hover:to-blue-700 text-white font-semibold py-3 text-base" size="lg" > {currentStep === "generating" ? ( <> <Loader2 className="w-5 h-5 mr-2 animate-spin" /> Membuat Script & Media... </> ) : ( <> <Zap className="w-5 h-5 mr-2" /> Generate Script + Media </> )} </Button> </div> </Card> )} {/* Loading State */} {currentStep === "generating" && ( <Card className="p-8 border-2 border-purple-200 bg-gradient-to-r from-purple-50 to-blue-50"> <div className="text-center space-y-4"> <div className="w-16 h-16 bg-gradient-to-r from-purple-500 to-blue-600 rounded-full flex items-center justify-center mx-auto animate-pulse"> <Wand2 className="text-white w-8 h-8" /> </div> <h3 className="text-xl font-semibold text-slate-900">Sedang Membuat Konten...</h3> <div className="space-y-2 max-w-md mx-auto"> <div className="flex items-center space-x-3 text-slate-600"> <Loader2 className="w-4 h-4 animate-spin" /> <span>Menganalisis topik dengan AI</span> </div> <div className="flex items-center space-x-3 text-slate-600"> <Clock className="w-4 h-4" /> <span>Mencari media HD dari Pexels</span> </div> <div className="flex items-center space-x-3 text-slate-600"> <TrendingUp className="w-4 h-4" /> <span>Mengoptimalkan untuk format vertikal</span> </div> </div> <p className="text-sm text-slate-500">Proses ini membutuhkan 10-15 detik</p> </div> </Card> )} {/* Generated Content */} {currentStep === "completed" && generatedContent && ( <div className="space-y-6"> {/* Script Section */} <Card> <div className="p-4 border-b border-slate-200"> <div className="flex items-center justify-between"> <div className="flex items-center space-x-3"> <div className="w-8 h-8 bg-purple-500 rounded-lg flex items-center justify-center"> <Wand2 className="text-white w-4 h-4" /> </div> <div> <h3 className="font-semibold text-slate-900">Script Video</h3> <p className="text-xs text-slate-600">Durasi: {generatedContent.script.duration} detik</p> </div> </div> <Button variant="outline" size="sm" onClick={() => copyToClipboard(formatScript(generatedContent.script))} > <Copy className="w-4 h-4 mr-2" /> Copy All </Button> </div> </div> <div className="p-4 space-y-4"> <div className="space-y-3"> <div className="p-3 bg-red-50 rounded-lg border border-red-200"> <div className="flex items-center space-x-2 mb-2"> <Badge variant="destructive" className="text-xs">HOOK</Badge> </div> <p className="text-sm text-red-900 font-medium">{generatedContent.script.hook}</p> </div> <div className="p-3 bg-blue-50 rounded-lg border border-blue-200"> <div className="flex items-center space-x-2 mb-2"> <Badge className="text-xs bg-blue-500">OPENING</Badge> </div> <p className="text-sm text-blue-900">{generatedContent.script.opening}</p> </div> <div className="p-3 bg-green-50 rounded-lg border border-green-200"> <div className="flex items-center space-x-2 mb-2"> <Badge className="text-xs bg-green-500">CONTENT</Badge> </div> <p className="text-sm text-green-900 whitespace-pre-line">{generatedContent.script.content}</p> </div> <div className="p-3 bg-orange-50 rounded-lg border border-orange-200"> <div className="flex items-center space-x-2 mb-2"> <Badge className="text-xs bg-orange-500">CTA</Badge> </div> <p className="text-sm text-orange-900">{generatedContent.script.cta}</p> </div> </div> </div> </Card> {/* Media Section */} <Card> <div className="p-4 border-b border-slate-200"> <div className="flex items-center space-x-3"> <div className="w-8 h-8 bg-green-500 rounded-lg flex items-center justify-center"> <Download className="text-white w-4 h-4" /> </div> <div> <h3 className="font-semibold text-slate-900">Downloaded Media</h3> <p className="text-xs text-slate-600">Total: {generatedContent.media.total} files</p> </div> </div> </div> <div className="p-4"> <div className="grid grid-cols-1 md:grid-cols-2 gap-4"> {generatedContent.media.images.map((image) => ( <div key={image.id} className="relative group border rounded-lg overflow-hidden bg-white shadow-sm hover:shadow-md transition-shadow"> <img src={image.thumbnail} alt={image.alt || `Image by ${image.photographer}`} className="w-full h-32 object-cover" /> <div className="p-3"> <div className="flex items-center justify-between mb-2"> <Badge variant="secondary" className="text-xs">IMAGE</Badge> <span className="text-xs text-slate-500">by {image.photographer}</span> </div> <div className="flex space-x-2"> <Button size="sm" variant="outline" onClick={() => handleDownload(image)} className="flex-1" > <Download className="w-3 h-3 mr-1" /> Download </Button> <Button size="sm" variant="outline" onClick={() => window.open(image.pexelsUrl, "_blank")} > <Image className="w-3 h-3" /> </Button> </div> </div> </div> ))} {generatedContent.media.videos.map((video) => ( <div key={video.id} className="relative group border rounded-lg overflow-hidden bg-white shadow-sm hover:shadow-md transition-shadow"> <img src={video.thumbnail} alt={`Video by ${video.photographer}`} className="w-full h-32 object-cover" /> <div className="absolute inset-0 bg-black bg-opacity-40 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity"> <div className="w-12 h-12 bg-white rounded-full flex items-center justify-center"> <Video className="w-6 h-6 text-slate-900" /> </div> </div> <div className="p-3"> <div className="flex items-center justify-between mb-2"> <div className="flex items-center space-x-2"> <Badge className="text-xs bg-blue-500">VIDEO</Badge> <span className="text-xs text-slate-500">{video.duration}s</span> </div> <span className="text-xs text-slate-500">by {video.photographer}</span> </div> <div className="flex space-x-2"> <Button size="sm" variant="outline" onClick={() => handleDownload(video)} className="flex-1" > <Download className="w-3 h-3 mr-1" /> Download </Button> <Button size="sm" variant="outline" onClick={() => window.open(video.pexelsUrl, "_blank")} > <Video className="w-3 h-3" /> </Button> </div> </div> </div> ))} </div> <div className="mt-4 p-3 bg-green-50 rounded-lg border border-green-200"> <div className="flex items-center space-x-2"> <CheckCircle className="text-green-600 w-4 h-4" /> <span className="text-sm text-green-800">All media optimized for 9:16 vertical format</span> </div> <p className="text-xs text-green-600 mt-1">Files are optimized for 9:16 vertical video format</p> </div> </div> </Card> {/* Google Drive Links */} {generatedContent?.driveLinks && generatedContent.driveLinks.length > 0 && ( <Card> <div className="p-4 border-b border-slate-200"> <div className="flex items-center space-x-3"> <div className="w-8 h-8 bg-blue-500 rounded-lg flex items-center justify-center"> <svg className="text-white w-4 h-4" viewBox="0 0 24 24" fill="currentColor"> <path d="M6.5 4.5L12 12.5L17.5 4.5H6.5ZM17.5 19.5L12 11.5L6.5 19.5H17.5ZM4 6.83V17.17L9.17 12L4 6.83ZM20 6.83L14.83 12L20 17.17V6.83Z"/> </svg> </div> <div> <h3 className="font-semibold text-slate-900">Google Drive Backup</h3> <p className="text-xs text-slate-600">All files automatically saved to your Drive</p> </div> </div> </div> <div className="p-4"> <div className="space-y-3"> {generatedContent.driveLinks.map((driveFile) => ( <div key={driveFile.id} className="flex items-center justify-between p-3 bg-blue-50 rounded-lg border border-blue-200"> <div className="flex items-center space-x-3"> <div className="w-8 h-8 bg-blue-100 rounded-lg flex items-center justify-center"> {driveFile.type === "video" ? ( <Video className="text-blue-600 w-4 h-4" /> ) : ( <Image className="text-blue-600 w-4 h-4" /> )} </div> <div> <div className="text-sm font-medium text-blue-900">{driveFile.name}</div> <div className="text-xs text-blue-600 capitalize">{driveFile.type} file</div> </div> </div> <Button size="sm" variant="outline" className="text-blue-600 border-blue-300 hover:bg-blue-100" onClick={() => window.open(driveFile.webViewLink, "_blank")} > Open in Drive </Button> </div> ))} <div className="mt-4 p-3 bg-green-50 rounded-lg border border-green-200"> <div className="flex items-center space-x-2"> <CheckCircle className="text-green-600 w-4 h-4" /> <span className="text-sm text-green-800">All files successfully backed up to Google Drive</span> </div> </div> </div> </div> </Card> )} {/* Action Buttons */} <div className="flex space-x-3"> <Button variant="secondary" className="flex-1" onClick={() => { setCurrentStep("idle"); setGeneratedContent(null); setTopic(""); }} > <Plus className="w-4 h-4 mr-2" /> Generate New </Button> <Button className="flex-1 bg-gradient-to-r from-green-500 to-green-600 hover:from-green-600 hover:to-green-700"> <Share className="w-4 h-4 mr-2" /> Share Project </Button> </div> </div> )} </div> </div> </div> ); }' > client/src/pages/video-generator.tsx && mkdir -p client/src/components/ui && echo 'import { cn } from "@/lib/utils"; function Skeleton({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) { return ( <div className={cn("animate-pulse rounded-md bg-muted", className)} {...props} /> ); } export { Skeleton };' > client/src/components/ui/skeleton.tsx && echo 'import * as React from "react"; import { Slot } from "@radix-ui/react-slot"; import { cva, type VariantProps } from "class-variance-authority"; import { cn } from "@/lib/utils"; const buttonVariants = cva( "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0", { variants: { variant: { default: "bg-primary text-primary-foreground hover:bg-primary/90", destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90", outline: "border border-input bg-background hover:bg-accent hover:text-accent-foreground", secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80", ghost: "hover:bg-accent hover:text-accent-foreground", link: "text-primary underline-offset-4 hover:underline", }, size: { default: "h-10 px-4 py-2", sm: "h-9 rounded-md px-3", lg: "h-11 rounded-md px-8", icon: "h-10 w-10", }, }, defaultVariants: { variant: "default", size: "default", }, } ); export interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement>, VariantProps<typeof buttonVariants> { asChild?: boolean; } const Button = React.forwardRef<HTMLButtonElement, ButtonProps>( ({ className, variant, size, asChild = false, ...props }, ref) => { const Comp = asChild ? Slot : "button"; return ( <Comp className={cn(buttonVariants({ variant, size, className }))} ref={ref} {...props} /> ); } ); Button.displayName = "Button"; export { Button, buttonVariants };' > client/src/components/ui/button.tsx && echo 'import * as React from "react"; import { cn } from "@/lib/utils"; const Input = React.forwardRef<HTMLInputElement, React.ComponentProps<"input">>( ({ className, type, ...props }, ref) => { return ( <input type={type} className={cn( "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm", className )} ref={ref} {...props} /> ); } ); Input.displayName = "Input"; export { Input };' > client/src/components/ui/input.tsx && echo 'import * as React from "react"; import { cn } from "@/lib/utils"; const Card = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>( ({ className, ...props }, ref) => ( <div ref={ref} className={cn( "rounded-lg border bg-card text-card-foreground shadow-sm", className )} {...props} /> ) ); Card.displayName = "Card"; const CardHeader = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>( ({ className, ...props }, ref) => ( <div ref={ref} className={cn("flex flex-col space-y-1.5 p-6", className)} {...props} /> ) ); CardHeader.displayName = "CardHeader"; const CardTitle = React.forwardRef<HTMLParagraphElement, React.HTMLAttributes<HTMLHeadingElement>>( ({ className, ...props }, ref) => ( <div ref={ref} className={cn( "text-2xl font-semibold leading-none tracking-tight", className )} {...props} /> ) ); CardTitle.displayName = "CardTitle"; const CardDescription = React.forwardRef<HTMLParagraphElement, React.HTMLAttributes<HTMLParagraphElement>>( ({ className, ...props }, ref) => ( <p ref={ref} className={cn("text-sm text-muted-foreground", className)} {...props} /> ) ); CardDescription.displayName = "CardDescription"; const CardContent = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>( ({ className, ...props }, ref) => ( <div ref={ref} className={cn("p-6 pt-0", className)} {...props} /> ) ); CardContent.displayName = "CardContent"; const CardFooter = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>( ({ className, ...props }, ref) => ( <div ref={ref} className={cn("flex items-center p-6 pt-0", className)} {...props} /> ) ); CardFooter.displayName = "CardFooter"; export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent };' > client/src/components/ui/card.tsx && echo 'import * as React from "react"; import { cn } from "@/lib/utils"; const Textarea = React.forwardRef<HTMLTextAreaElement, React.ComponentProps<"textarea">>( ({ className, ...props }, ref) => { return ( <textarea className={cn( "flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm", className )} ref={ref} {...props} /> ); } ); Textarea.displayName = "Textarea"; export { Textarea };' > client/src/components/ui/textarea.tsx && echo 'import * as React from "react"; import * as LabelPrimitive from "@radix-ui/react-label"; import { cva, type VariantProps } from "class-variance-authority"; import { cn } from "@/lib/utils"; const labelVariants = cva( "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70" ); const Label = React.forwardRef<React.ElementRef<typeof LabelPrimitive.Root>, React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> & VariantProps<typeof labelVariants>>( ({ className, ...props }, ref) => ( <LabelPrimitive.Root ref={ref} className={cn(labelVariants(), className)} {...props} /> ) ); Label.displayName = LabelPrimitive.Root.displayName; export { Label };' > client/src/components/ui/label.tsx && echo 'import * as React from "react"; import * as SliderPrimitive from "@radix-ui/react-slider"; import { cn } from "@/lib/utils"; const Slider = React.forwardRef<React.ElementRef<typeof SliderPrimitive.Root>, React.ComponentPropsWithoutRef<typeof SliderPrimitive.Root>>( ({ className, ...props }, ref) => ( <SliderPrimitive.Root ref={ref} className={cn( "relative flex w-full touch-none select-none items-center", className )} {...props} > <SliderPrimitive.Track className="relative h-2 w-full grow overflow-hidden rounded-full bg-secondary"> <SliderPrimitive.Range className="absolute h-full bg-primary" /> </SliderPrimitive.Track> <SliderPrimitive.Thumb className="block h-5 w-5 rounded-full border-2 border-primary bg-background ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50" /> </SliderPrimitive.Root> ) ); Slider.displayName = SliderPrimitive.Root.displayName; export { Slider };' > client/src/components/ui/slider.tsx && echo 'import * as React from "react"; import { cva, type VariantProps } from "class-variance-authority"; import { cn } from "@/lib/utils"; const badgeVariants = cva( "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2", { variants: { variant: { default: "border-transparent bg-primary text-primary-foreground hover:bg-primary/80", secondary: "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80", destructive: "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80", outline: "text-foreground", }, }, defaultVariants: { variant: "default", }, } ); export interface BadgeProps extends React.HTMLAttributes<HTMLDivElement>, VariantProps<typeof badgeVariants> {} function Badge({ className, variant, ...props }: BadgeProps) { return ( <div className={cn(badgeVariants({ variant }), className)} {...props} /> ); } export { Badge, badgeVariants };' > client/src/components/ui/badge.tsx && echo 'import * as React from "react"; import * as SeparatorPrimitive from "@radix-ui/react-separator"; import { cn } from "@/lib/utils"; const Separator = React.forwardRef<React.ElementRef<typeof SeparatorPrimitive.Root>, React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>>( ( { className, orientation = "horizontal", decorative = true, ...props }, ref ) => ( <SeparatorPrimitive.Root ref={ref} decorative={decorative} orientation={orientation} className={cn( "shrink-0 bg-border", orientation === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]", className )} {...props} /> ) ); Separator.displayName = SeparatorPrimitive.Root.displayName; export { Separator };' > client/src/components/ui/separator.tsx && echo 'import * as React from "react" import * as ToastPrimitives from "@radix-ui/react-toast" import { cva, type VariantProps } from "class-variance-authority" import { X } from "lucide-react" import { cn } from "@/lib/utils" const ToastProvider = ToastPrimitives.Provider const ToastViewport = React.forwardRef<React.ElementRef<typeof ToastPrimitives.Viewport>, React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>>( ({ className, ...props }, ref) => ( <ToastPrimitives.Viewport ref={ref} className={cn( "fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]", className )} {...props} /> ) ) ToastViewport.displayName = ToastPrimitives.Viewport.displayName const toastVariants = cva( "group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full", { variants: { variant: { default: "border bg-background text-foreground", destructive: "destructive border-destructive bg-destructive text-destructive-foreground", }, }, defaultVariants: { variant: "default", }, } ) const Toast = React.forwardRef<React.ElementRef<typeof ToastPrimitives.Root>, React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> & VariantProps<typeof toastVariants>>( ({ className, variant, ...props }, ref) => { return ( <ToastPrimitives.Root ref={ref} className={cn(toastVariants({ variant }), className)} {...props} /> ) } ) Toast.displayName = ToastPrimitives.Root.displayName const ToastAction = React.forwardRef<React.ElementRef<typeof ToastPrimitives.Action>, React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>>( ({ className, ...props }, ref) => ( <ToastPrimitives.Action ref={ref} className={cn( "inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive", className )} {...props} /> ) ) ToastAction.displayName = ToastPrimitives.Action.displayName const ToastClose = React.forwardRef<React.ElementRef<typeof ToastPrimitives.Close>, React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>>( ({ className, ...props }, ref) => ( <ToastPrimitives.Close ref={ref} className={cn( "absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600", className )} toast-close="" {...props} > <X className="h-4 w-4" /> </ToastPrimitives.Close> ) ) ToastClose.displayName = ToastPrimitives.Close.displayName const ToastTitle = React.forwardRef<React.ElementRef<typeof ToastPrimitives.Title>, React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>>( ({ className, ...props }, ref) => ( <ToastPrimitives.Title ref={ref} className={cn("text-sm font-semibold", className)} {...props} /> ) ) ToastTitle.displayName = ToastPrimitives.Title.displayName const ToastDescription = React.forwardRef<React.ElementRef<typeof ToastPrimitives.Description>, React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>>( ({ className, ...props }, ref) => ( <ToastPrimitives.Description ref={ref} className={cn("text-sm opacity-90", className)} {...props} /> ) ) ToastDescription.displayName = ToastPrimitives.Description.displayName type ToastProps = React.ComponentPropsWithoutRef<typeof Toast> type ToastActionElement = React.ReactElement<typeof ToastAction> export { type ToastProps, type ToastActionElement, ToastProvider, ToastViewport, Toast, ToastTitle, ToastDescription, ToastClose, ToastAction, }' > client/src/components/ui/toast.tsx && echo '{ "name": "video-generator", "version": "1.0.0", "type": "module", "main": "index.js", "scripts": { "dev": "NODE_ENV=development tsx server/index.ts", "build": "npm run build:client && npm run build:server", "build:client": "vite build", "build:server": "esbuild server/index.ts --bundle --platform=node --target=node20 --outfile=dist/server.js --external:express" }, "dependencies": { "@google/genai": "^1.1.0", "@hookform/resolvers": "^3.9.1", "@jridgewell/trace-mapping": "^0.3.25", "@neondatabase/serverless": "^0.10.2", "@radix-ui/react-accordion": "^1.2.1", "@radix-ui/react-alert-dialog": "^1.1.2", "@radix-ui/react-aspect-ratio": "^1.1.0", "@radix-ui/react-avatar": "^1.1.1", "@radix-ui/react-checkbox": "^1.1.2", "@radix-ui/react-collapsible": "^1.1.1", "@radix-ui/react-context-menu": "^2.2.2", "@radix-ui/react-dialog": "^1.1.2", "@radix-ui/react-dropdown-menu": "^2.1.2", "@radix-ui/react-hover-card": "^1.1.2", "@radix-ui/react-label": "^2.1.0", "@radix-ui/react-menubar": "^1.1.2", "@radix-ui/react-navigation-menu": "^1.2.1", "@radix-ui/react-popover": "^1.1.2", "@radix-ui/react-progress": "^1.1.0", "@radix-ui/react-radio-group": "^1.2.1", "@radix-ui/react-scroll-area": "^1.2.0", "@radix-ui/react-select": "^2.1.2", "@radix-ui/react-separator": "^1.1.0", "@radix-ui/react-slider": "^1.2.1", "@radix-ui/react-slot": "^1.1.0", "@radix-ui/react-switch": "^1.1.1", "@radix-ui/react-tabs": "^1.1.1", "@radix-ui/react-toast": "^1.2.2", "@radix-ui/react-toggle": "^1.1.0", "@radix-ui/react-toggle-group": "^1.1.0", "@radix-ui/react-tooltip": "^1.1.3", "@replit/vite-plugin-cartographer": "^2.1.1", "@replit/vite-plugin-runtime-error-modal": "^2.0.0", "@tailwindcss/typography": "^0.5.15", "@tailwindcss/vite": "^4.0.0-alpha.26", "@tanstack/react-query": "^5.62.2", "@types/connect-pg-simple": "^7.0.3", "@types/express": "^5.0.0", "@types/express-session": "^1.18.0", "@types/node": "^22.10.1", "@types/passport": "^1.0.16", "@types/passport-local": "^1.0.38", "@types/react": "^18.3.12", "@types/react-dom": "^18.3.1", "@types/ws": "^8.5.13", "@vitejs/plugin-react": "^4.3.4", "autoprefixer": "^10.4.20", "class-variance-authority": "^0.7.1", "clsx": "^2.1.1", "cmdk": "^1.0.4", "connect-pg-simple": "^10.0.0", "date-fns": "^4.1.0", "drizzle-kit": "^0.29.0", "drizzle-orm": "^0.36.4", "drizzle-zod": "^0.7.0", "embla-carousel-react": "^8.3.1", "esbuild": "^0.24.0", "express": "^4.21.1", "express-session": "^1.18.1", "framer-motion": "^11.13.1", "googleapis": "^144.0.0", "input-otp": "^1.4.1", "lucide-react": "^0.460.0", "memorystore": "^1.6.7", "next-themes": "^0.4.4", "node-fetch": "^3.3.2", "passport": "^0.7.0", "passport-local": "^1.0.0", "postcss": "^8.5.0", "react": "^18.3.1", "react-day-picker": "^9.4.2", "react-dom": "^18.3.1", "react-hook-form": "^7.54.0", "react-icons": "^5.4.0", "react-resizable-panels": "^2.1.7", "recharts": "^2.13.3", "tailwind-merge": "^2.5.4", "tailwindcss": "^3.4.14", "tailwindcss-animate": "^1.0.7", "tsx": "^4.19.2", "tw-animate-css": "^1.0.1", "typescript": "^5.6.3", "vaul": "^1.1.1", "vite": "^6.0.1", "wouter": "^3.3.5", "ws": "^8.18.0", "zod": "^3.23.8", "zod-validation-error": "^3.4.0" } }' > package.json && echo 'node_modules dist .env .env.local .env.production .env.staging *.log .DS_Store Thumbs.db' > .gitignore && npm install && npm run dev
